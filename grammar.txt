(*
  Typed Lisp Surface Syntax — Consolidated EBNF + Reader Rules
  ------------------------------------------------------------
  Conventions / notes:
  - Token boundaries are explicit: whitespace, '(' , ')' , and '"' delimit tokens.
  - ':' does not require spaces around it in source.
  - '->' is reserved (currently) and used only in signatures and arrow types.
  - Types are lowercase and reserved (cannot be used as value identifiers).
  - Identifiers are case-sensitive.
  - Value identifiers may include '?' ; type identifiers do NOT include '?'.
  - Strings use " ... " ; ';' starts a line comment.
  - Reader macro prefixes: ' ` , ,@  (desugar to quote/quasiquote/unquote/unquote-splicing).
  - Bodies are SINGLE expressions; use (do ...) for sequencing.
*)

(* ------------------------- LEXICAL ------------------------- *)

WS        ::= (" " | "\t" | "\r" | "\n")+ ;
COMMENT   ::= ";" { any-char-except-newline } ;

LPAREN    ::= "(" ;
RPAREN    ::= ")" ;
COLON     ::= ":" ;
DQUOTE    ::= "\"" ;

END       ::= end-of-input ;

QUOTE_P      ::= "'" ;
QQ_P         ::= "`" ;
UNQSPLICE_P  ::= ",@" ;        (* match before ',' *)
UNQUOTE_P    ::= "," ;

ALPHA_U   ::= "A"…"Z" ;
ALPHA_L   ::= "a"…"z" ;
ALPHA     ::= ALPHA_U | ALPHA_L ;
DIGIT     ::= "0"…"9" ;

SIGN      ::= "+" | "-" ;
UINT      ::= DIGIT { DIGIT } ;

(* value identifiers: allow '?' *)
IDCHAR    ::= ALPHA | DIGIT | "?" ;
IDENT     ::= ALPHA { IDCHAR } { "-" IDCHAR { IDCHAR } } ;

(* type identifiers: lowercase + digits + '-' segments; NO '?' *)
TYCHAR    ::= ALPHA_L | DIGIT ;
TYPE_IDENT ::= ALPHA_L { TYCHAR } { "-" TYCHAR { TYCHAR } } ;

(* operator symbols: punctuation-only, contiguous combos; includes '->' *)
OPCHAR    ::= "+" | "-" | "*" | "/" | "%" | "^" | "<" | ">" | "=" | "!" | "|" | "\" ;
OPSYM     ::= OPCHAR { OPCHAR } ;

BOOL      ::= "#t" | "#f" ;

(* strings *)
STRING    ::= DQUOTE { STR_CHAR } DQUOTE ;
STR_CHAR  ::= ESCAPED | any-char-except-DQUOTE-or-newline ;
ESCAPED   ::= "\" ( "\" | DQUOTE | "n" | "t" | "r" ) ;

(* numeric literals: floats must have digits on both sides of '.' *)
INT       ::= [SIGN] UINT ;
FLOAT     ::= [SIGN] UINT "." UINT ;
RATIONAL  ::= [SIGN] UINT "/" UINT ;

REAL      ::= RATIONAL | FLOAT | INT ;

(* complex literals must contain 'i'; NO SPACES; digits-only are NOT complex *)
IMAG_ONLY ::= [SIGN] [REAL] "i" ;             (* 'i', '+i', '-i', '3i', '-2.5i', '3/4i' *)
REAL_IMAG ::= REAL ("+"|"-") [REAL] "i" ;     (* '2-i', '1+2i', '3/4-5/6i' *)
COMPLEX   ::= IMAG_ONLY | REAL_IMAG ;

ATOM      ::= STRING | BOOL | COMPLEX | RATIONAL | FLOAT | INT | IDENT | OPSYM ;


(* --------------------- READER MACROS ---------------------- *)

(*
  Reader desugaring (performed before core parsing):
    '  X   => (quote X)
    `  X   => (quasiquote X)
    ,  X   => (unquote X)
    ,@ X   => (unquote-splicing X)

  Semantic restriction:
    unquote / unquote-splicing are only valid within quasiquote.
*)


(* ------------------------- SYNTAX -------------------------- *)

program        ::= { form } ;
form           ::= expr ;

expr           ::= atom
                 | prefix_expr
                 | list ;

atom           ::= ATOM ;

prefix_expr    ::= QUOTE_P expr
                 | QQ_P expr
                 | UNQSPLICE_P expr
                 | UNQUOTE_P expr ;

list           ::= LPAREN list_contents RPAREN ;

list_contents  ::= special_form
                 | { expr } ;                  (* application / general list *)


(* ---------------------- SPECIAL FORMS ---------------------- *)

special_form   ::= do_form
                 | lambda_form
                 | define_form
                 | let_form
                 | quote_form
                 | quasiquote_form
                 | unquote_form
                 | unquote_splicing_form
                 | cond_form
                 | cons_form
                 | shift_form
                 | reset_form
                 | force_form ;

do_form        ::= "do" expr { expr } ;
cons_form      ::= "cons" expr expr ;
shift_form     ::= "shift" expr ;
reset_form     ::= "reset" expr ;
force_form     ::= "force" expr ;

quote_form            ::= "quote" expr ;
quasiquote_form       ::= "quasiquote" expr ;
unquote_form          ::= "unquote" expr ;
unquote_splicing_form ::= "unquote-splicing" expr ;

(* cond: (cond ((expr) expr) ... ((expr) expr)) *)
cond_form      ::= "cond" cond_clause { cond_clause } ;
cond_clause    ::= LPAREN LPAREN expr RPAREN expr RPAREN ;


(* -------------------- TYPED BINDINGS ----------------------- *)

(* binder: (name:Type) *)
binder         ::= LPAREN IDENT COLON type RPAREN ;

(* signatures are explicit; required in lambda/define-function *)
(* nullary params use () *)
signature      ::= LPAREN sig_params "->" type RPAREN ;
sig_params     ::= LPAREN RPAREN
                 | { binder } ;

(* lambda: (lambda ( ...binders... -> Type ) bodyExpr) *)
(* parsed as: (LAMBDA (PARAM_LIST (name type) ... (RETURN_TYPE Type)) bodyExpr) *)
lambda_form    ::= "lambda" signature expr ;

(* define:
     value:    (define x:int expr)
     function: (define foo (x:int y:int -> int) expr)
*)
define_form        ::= "define" define_value
                     | "define" define_function ;

define_value       ::= IDENT COLON type expr ;
define_function    ::= IDENT signature expr ;

(* let / lets / letr:
     (let  (((x : T) v) ((y : U) w)) body)
     (lets (((x : T) v) ((y : U) w)) body)
     (letr (((f : (.. -> ..)) (lambda ...)) ...) body)
*)
let_form        ::= let_kw LPAREN { let_binding } RPAREN expr ;
let_kw          ::= "let" | "lets" | "letr" ;
let_binding     ::= LPAREN binder expr RPAREN ;


(* -------------------------- TYPES -------------------------- *)

(* nat used in fixed-length vectors *)
NAT            ::= UINT ;

type           ::= type_atom
                 | type_compound ;

type_atom      ::= TYPE_IDENT ;                 (* lowercase reserved: int, bool, rational, float, complex, char, string, symbol, list, vec, ... *)

type_compound  ::= vec_type
                 | arrow_type
                 | type_ctor ;

(* fixed-length vectors *)
vec_type       ::= LPAREN "vec" type NAT RPAREN ;

(* arrow types: only in parentheses; right-associative *)
arrow_type     ::= LPAREN type "->" type { "->" type } RPAREN ;

(* generic type constructor for future composites *)
type_ctor      ::= LPAREN TYPE_IDENT { type | NAT } RPAREN ;


(* -------------------- SEMANTIC RESTRICTIONS -------------------- *)

(*
  - ':' must be surrounded by whitespace in source.
  - '->' is reserved (currently) and not a general identifier/operator outside type/signature positions.
  - TYPE_IDENT are lowercase and reserved: they cannot be used as value IDENT.
  - TYPE_IDENT does not include '?'; value IDENT may include '?'.
  - Bodies are single expressions; use (do ...) for sequencing.
  - unquote/unquote-splicing only valid within quasiquote.
  - floats must match [+-]?\d+\.\d+ (no '.5' or '5.').
  - complex literals must contain 'i'; digits-only tokens are never complex.
*)
